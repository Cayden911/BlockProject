/**
 * @license
 * Copyright 2012 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Generating Python for variable blocks.
 * @author q.neutron@gmail.com (Quynh Neutron)
 */
'use strict';

//goog.provide('Blockly.Python.variables');

//goog.require('Blockly.Python');


Blockly.Python['variables_get'] = function(block) {
  // Variable getter.
  var code = Blockly.Python.variableDB_.getName(block.getFieldValue('VAR'),
      Blockly.VARIABLE_CATEGORY_NAME);
  return [code, Blockly.Python.ORDER_ATOMIC];
};

Blockly.Python['variables_set'] = function(block) {
  // Variable setter.
  var argument0 = Blockly.Python.valueToCode(block, 'VALUE',
      Blockly.Python.ORDER_NONE) || '0';
  var varName = Blockly.Python.variableDB_.getName(block.getFieldValue('VAR'),
      Blockly.VARIABLE_CATEGORY_NAME);
  return varName + ' = ' + argument0 + '\n';
};

Blockly.Python['new_robot'] = function(block) {
  var text_name = block.getFieldValue('name');
  var number_x_val = block.getFieldValue('x_val');
  var number_y_val = block.getFieldValue('y_val');
  var angle_theta = block.getFieldValue('theta');
  
  var code =`

  import rps.robotarium as robotarium
  from rps.utilities.transformations import *
  from rps.utilities.barrier_certificates import *
  from rps.utilities.misc import *
  from rps.utilities.controllers import *
  
  import numpy as np
  import time
  
  N = 1
initial_conditions = np.array(np.array([[`+String(number_x_val)+`], [`+String(number_y_val)+`], [`+String(angle_theta*3.14/180)+`]]))
r = robotarium.Robotarium(number_of_robots=N, show_figure=True, initial_conditions=initial_conditions, sim_in_real_time=False)

unicycle_position_controller = create_clf_unicycle_position_controller()

# Create barrier certificates to avoid collision
uni_barrier_cert = create_unicycle_barrier_certificate()

r.get_poses()
r.step()
for i in range(100000):
    x = r.get_poses()
    
    dxu = unicycle_position_controller(x, np.array([[0, 0], [1, -1]]))
    #dxu = uni_barrier_cert(dxu, x)

    # Set the velocities by mapping the single-integrator inputs to unciycle inputs
    r.set_velocities(np.arange(N), dxu)
    print(np.arange(N))
    # Iterate the simulation
    
    r.step()

r.call_at_scripts_end()

  
  `;
  return code;
};