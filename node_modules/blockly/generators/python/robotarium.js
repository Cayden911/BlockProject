/**
 * @license
 * Copyright 2012 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Generating Python for variable blocks.
 * @author q.neutron@gmail.com (Quynh Neutron)
 */
 'use strict';


 

//This block creates a new robot
Blockly.Python['new_robot'] = function(block) {
  var text_name = block.getFieldValue('name');
  var number_x_val = block.getFieldValue('x_val');
  var number_y_val = block.getFieldValue('y_val');
  var angle_theta = block.getFieldValue('theta');
  var robot_color = Blockly.Python.valueToCode(block, 'color', Blockly.Python.ORDER_ATOMIC);
  if (robot_color == '') robot_color = '"black"';
   var code = `
curName = "`+text_name+`"
drawing = -1
New_Robot(curName,`+number_x_val+`,`+number_y_val+`,`+angle_theta+`,`+robot_color+`,drawing)
`;
   return code;
 };

//This block runs the robot to a point and angle
Blockly.Python['run_to_point_and_angle'] = function(block) {
   var number_target_x = block.getFieldValue('target_x');
   var number_target_y = block.getFieldValue('target_y');
   var angle = block.getFieldValue('angle');   
   var code = "Add_Target_Point(curName,"+number_target_x+","+number_target_y+","+angle+",drawing)\n";
   return code;
 };

//This block runs the robot to a point and angle
Blockly.Python['run_to_point'] = function(block) {
  var number_target_x = block.getFieldValue('target_x');
  var number_target_y = block.getFieldValue('target_y');
  var code = "Add_Target_Point(curName,"+number_target_x+","+number_target_y+",0,drawing)\n";
  return code;
};

//This block puts the robots "pen" down
Blockly.Python['pen_down'] = function(block) {
  var color = Blockly.Python.valueToCode(block, 'color', Blockly.Python.ORDER_ATOMIC);
  if (color == "") color = "'#000000'";
  color = color.slice(2,-1);
  color = parseInt(color,16);
  var code = `
drawing = `+color+`
`;
  return code;
};

//This block pulls the robots "pen" up
Blockly.Python['pen_up'] = function(block) {
  var code = "drawing = -1\n";
  return code;
};

Blockly.Python['new_polygon'] = function(block) {
  var number_sides = block.getFieldValue('sides');
  var number_x = block.getFieldValue('x');
  var number_y = block.getFieldValue('y');
  var number_radius = block.getFieldValue('radius');
  var angle_angle = block.getFieldValue('angle');
  var value_color = Blockly.Python.valueToCode(block, 'color', Blockly.Python.ORDER_ATOMIC);
  if (value_color == "") value_color = "'#000000'";
  // TODO: Assemble Python into code variable.
  var code = `robotarium.patches.RegularPolygon([`+number_x+`,`+number_y+`],`+number_sides+`, radius=`+number_radius+`, orientation=`+angle_angle+`, color=`+value_color+`)\n`;
  return code;
};

//This block changes the drawing type between actual or initial
Blockly.Python['drawing_type'] = function(block) {
  var dropdown_d_type = block.getFieldValue('D_type');
  var code = "drawingType = \""+dropdown_d_type+"\"\n";
  return code;
};

Blockly.Python['new_circle'] = function(block) {
  var number_x = block.getFieldValue('x');
  var number_y = block.getFieldValue('y');
  var number_radius = block.getFieldValue('radius');
  var value_color = Blockly.Python.valueToCode(block, 'color', Blockly.Python.ORDER_ATOMIC);
  // TODO: Assemble Python into code variable.
  var code = '...\n';
  return code;
};

//This block makes the robot turn by heading
Blockly.Python['turn_by_angle'] = function(block) {
  var angle_angle = block.getFieldValue('angle');
  var code = "robotList[namesList.index(curName)].turn("+angle_angle+",drawing)\n";
  return code;
};

//This block makes the robot move forward by distance
Blockly.Python['move_forward'] = function(block) {
  var number_distance = block.getFieldValue('distance');
  var code = "robotList[namesList.index(curName)].move_Forward("+number_distance+",drawing)\n";
  return code;
};

//This block makes the robot wait a specified time
Blockly.Python['wait'] = function(block) {
  var seconds = block.getFieldValue('seconds');
  var miliseconds = seconds * 1000
  console.log(robotList[namesList.index(curName)].target_Array[-1][0])
  console.log(robotList[namesList.index(curName)].target_Array[-1][1])
  var code = `Add_Target_Point(curName,robotList[namesList.index(curName)].target_Array[-1][0],robotList[namesList.index(curName)].target_Array[-1][1],0,-2)\n`;
  return code;
};

//This block places an image
Blockly.Python['display_image'] = function(block) {
  var text_link = block.getFieldValue('link');
  var number_x = block.getFieldValue('x');
  var number_y = block.getFieldValue('y');
  var number_w = block.getFieldValue('w');
  var number_h = block.getFieldValue('h');
  var code = `
  
  `;
  return code;
};

//This block turns to a spicific heading
Blockly.Python['turn_to'] = function(block) {
  var angle_angle = block.getFieldValue('angle');
  var code = "robotList[namesList.index(curName)].turn_To("+angle_angle+",drawing)\n";
  return code;
};

Blockly.Python['initializeRobotarium'] = function(block) {
  var robotInitializeCode = Blockly.Python.statementToCode(block, 'robotInitializeCode');
  var whileLoopCode = Blockly.Python.statementToCode(block, 'whileLoopCode');
  // TODO: Assemble Python into code variable.
  var code = `
  # importing necesary robotarium libraries
from rps.utilities.transformations import *
from rps.utilities.barrier_certificates import *
from rps.utilities.misc import *
from rps.utilities.controllers import *

# importing other necessary libraries
import numpy as np
import time
import math

#Here we define the Robot class in order to condense the code output by the blocks and make that easier to read
class Robot:

    #This sets up theInitial conditions for the  blocks to modify 
    def __init__(self, name, x, y, t, drawing):
        self.target_points = []
        self.currentPoint = 0
        self.totalPoints = 0
        self.finished = False
        self.output_points = np.array([[],[],[]])
        t=t%360
        if(t>180):
            t=t-360
        theta = t * 3.14/180
        self.name = name
        self.start_array = np.array([[x],[y],[theta],[drawing]])
        self.target_points.append((x,y,theta,drawing))
        self.output_points = np.array([[x],[y],[theta],[drawing]])
    
    #this block adds a target point to the target_points array for a specific robot
    def add_Target_Point(self,x,y,t,drawing):
        self.totalPoints = self.totalPoints + 1
        t=t%360
        if(t>180):
            t=t-360
        self.target_points.append((x,y,t*3.14/180,drawing))

    #returns the 2D target points aray for a specific robot
    def get_Target_Points(self):
        return self.target_points

    #This turns the tuple array of self.target points into the array of strings that other functions require
    def update_Output_Points(self):
        self.output_points[0] = self.target_points[self.currentPoint][0]
        self.output_points[1] = self.target_points[self.currentPoint][1]
        self.output_points[2] = self.target_points[self.currentPoint][2]
        self.output_points[3] = self.target_points[self.currentPoint][3]
    
    #This function moves the robot to the next step and if it is finished, it sets self.finished to true
    def step_Current_Point(self):
        self.currentPoint = self.currentPoint + 1
        if(self.currentPoint > self.totalPoints):
            self.finished = True
        if(not self.finished):
            self.update_Output_Points()
    
    #Displays output points
    def get_Output_Points(self):
        return self.output_points
    
    #checks if a robot is within the allowed degrees of a specified angle
    def angle_In_Range(self, angle, accuracy = .07):
      if((self.target_points[self.currentPoint][2]-accuracy < angle < self.target_points[self.currentPoint][2]+accuracy)):
              return True     
      elif(self.target_points[self.currentPoint][2] == 3.14):
          if(3.14-accuracy < math.fabs(angle) < 3.14+accuracy):
              return True
      else:
          return False

    #checks if a robot is within the allowed distance of a point
    def check_Position(self,robot_num, pos, accuracy = .03):
        if(not self.finished):
            if((self.target_points[self.currentPoint][0]-accuracy < pos[0][robot_num] < self.target_points[self.currentPoint][0]+accuracy) and (self.target_points[self.currentPoint][1]-accuracy < pos[1][robot_num] < self.target_points[self.currentPoint][1]+accuracy) and (self.angle_In_Range(pos[2][robot_num]))):
                self.step_Current_Point()
                return True
            else:
                return False

    #returns of a robot is finished or not
    def get_Status(self):
        return self.finished

    #Sets a point the specified distance ahead of the robot at the same ange as the starting angle.
    #it then adds that point to the target array
    def move_Forward(self, distance, drawing):
        curX = self.target_points[self.totalPoints][0]
        curY = self.target_points[self.totalPoints][1]
        curT = self.target_points[self.totalPoints][2]
        addX = distance * math.cos(curT)
        addY = distance * math.sin(curT)
        self.add_Target_Point((curX+addX),(curY+addY),(curT*180/3.14),drawing)
    
    #adds a target point at the robot's current position, but turned by the specified angle
    def turn(self,by,drawing):
    curX = self.target_points[self.totalPoints][0]
    #   curY = self.target_points[self.totalPoints][1]
    #   curT = self.target_points[self.totalPoints][2]*180/3.14
    #   curT = (curT + by)%360
    #   self.add_Target_Point((curX),(curY),(curT),drawing)

    #turns the robot to a specified angle on the spot
    def turn_To(self,to,drawing):
    #   curX = self.target_points[self.totalPoints][0]
    #   curY = self.target_points[self.totalPoints][1]
    #   self.add_Target_Point((curX),(curY),(to),drawing)

#necessary lists
#list of robot objects
robotList = []
#list of the robot's names
namesList = []
#list of the robot's colors
robotColorsList = []
#list of the label objecs that stay above the robots displaying their names
robot_labels = []
#list of the ideal lines that the robots are currently drawing
robotLines = []
#sets a time limit on the simulation
t_end = time.time() + 60 * 5
#sets initialy not drawing
drawing = -1
#sets default drawing type to ideal
drawingType = "Ideal"

#fills the start array with all of the initial robot positions
def Fill_Start_Array():
    start_Array = np.array([[],[],[],[]])
    for robot in robotList:
        start_Array = np.append(start_Array,robot.get_Output_Points(), axis = 1)
    return start_Array

#Consolidares all of the robot's output arrays into a single array
def Update_Target_Array(pos):
    target_Array = np.array([[],[],[],[]])
    for i in range(len(robotList)):
        robotList[i].check_Position(i,pos)
        target_Array = np.append(target_Array,robotList[i].get_Output_Points(), axis = 1)
    return target_Array

#checks if for every robot, self.finished == true
def Check_if_All_Done():
    for robot in robotList:
        if(robot.get_Status() == False):
            return False
    return True

#initializes a robot
def New_Robot(name, x,y,t,color,drawing):
    namesList.append(name)
    robotList.append(Robot(name,x,y,t,drawing))
    robotColorsList.append(color)
    robotLines.append([])

#adds passed in point to target array
def Add_Target_Point(name, x,y,t,drawing):
    robotList[namesList.index(name)].add_Target_Point(x,y,t,drawing)

`+robotInitializeCode+`
start_Array = Fill_Start_Array()
#initializes the robotarium object
r = robotarium.Robotarium(number_of_robots=len(robotList), show_figure=True, initial_conditions=start_Array[0:3][:], sim_in_real_time=False)
#starts the controler that drives the robots
unicycle_position_controller = create_hybrid_unicycle_pose_controller()
#creates barrier certificate
uni_barrier_cert = create_unicycle_barrier_certificate()
_,uni_to_si_states = create_si_to_uni_mapping()
#gets robot positions
x = r.get_poses()
r.step()

#generates robot list
robot_labels = [r.axes.text(x[0,namesList.index(kk)],x[1,namesList.index(kk)]+0.15,kk,fontsize=8, color=robotColorsList[namesList.index(kk)],fontweight='bold',horizontalalignment='center',verticalalignment='center',zorder=0)
for kk in namesList]

#ii is necessary so that the robot draws every few frames and doesn't overload the computer
ii = 0
#used for actual to track drawing
drawFrame = False

#for ideal drawing, it sets up a place for the step of the previous line to be stored
if drawingType == "Ideal":
    lineStepCache = []
    for nn in robotList:
        lineStepCache.append(0)

#loop that runs everything
while time.time() < t_end:
`+whileLoopCode+`
#run at end of the program
r.call_at_scripts_end()

`;
  return code;
};